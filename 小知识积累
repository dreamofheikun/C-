class B
{
public:
  explicit B();
};
上述的构造函数被声明为explicit，这可阻止它被用来执行隐士类型转换，但仍可用来进行显示类型转换。
////////////////////////////////////////////////////////////////////////////////////////////
class Wdiget
{
public:
  Widget();                               //default构造函数
  Widget(const Widget &rhs);              //copy构造函数
  Widget& operator=(const Widget& rhs);   //copy assignment操作符
};
Wdiget w1;                                //调用default构造函数
Widget w2(w1);                            //调用copy构造函数
w1=w2;                                    //调用copy assignment操作符
Widget w3=w2;                             //调用copy构造函数
如果一个新对象被定义（例如以上语句中的w3），一定会有个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的“w1=w2”语句），
  就不会有构造函数被调用，那么当然就是赋值操作被调用。
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
